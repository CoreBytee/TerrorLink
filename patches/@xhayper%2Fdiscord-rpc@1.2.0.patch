diff --git a/node_modules/@xhayper/discord-rpc/.bun-tag-9915706171859cc3 b/.bun-tag-9915706171859cc3
new file mode 100644
index 0000000000000000000000000000000000000000..e69de29bb2d1d6434b8b29ae775ad8c2e48c5391
diff --git a/dist/Client.d.ts b/dist/Client.d.ts
index 901070a96cacc37ab158fedcbc49d09fe6f5a254..72fd50d6d9503c2e6564dc985d4f27fb26f445e9 100644
--- a/dist/Client.d.ts
+++ b/dist/Client.d.ts
@@ -2,110 +2,126 @@ import { type APIApplication, type OAuth2Scopes } from "discord-api-types/v10";
 import { AsyncEventEmitter } from "@vladfrangu/async_event_emitter";
 import { type PathData } from "./transport/IPC";
 import { ClientUser } from "./structures/ClientUser";
-import { type RPC_CMD, type CommandIncoming, type RPC_EVT, type Transport, type TransportOptions } from "./structures/Transport";
+import {
+	type RPC_CMD,
+	type CommandIncoming,
+	type RPC_EVT,
+	type Transport,
+	type TransportOptions,
+} from "./structures/Transport";
 export type AuthorizeOptions = {
-    scopes: (OAuth2Scopes | `${OAuth2Scopes}`)[];
-    prompt?: "consent" | "none";
-    useRPCToken?: boolean;
-    refreshToken?: string;
+	scopes: (OAuth2Scopes | `${OAuth2Scopes}`)[];
+	prompt?: "consent" | "none";
+	useRPCToken?: boolean;
+	refreshToken?: string;
 };
 export interface ClientOptions {
-    /**
-     * application id
-     */
-    clientId: string;
-    /**
-     * application secret
-     */
-    clientSecret?: string;
-    /**
-     * pipe id
-     */
-    pipeId?: number;
-    /**
-     * transport configs
-     */
-    transport?: {
-        /**
-         * transport type
-         */
-        type?: "ipc" | "websocket" | {
-            new (options: TransportOptions): Transport;
-        };
-        /**
-         * ipc transport's path list
-         */
-        pathList?: PathData[];
-    };
+	/**
+	 * application id
+	 */
+	clientId: string;
+	/**
+	 * application secret
+	 */
+	clientSecret?: string;
+	/**
+	 * pipe id
+	 */
+	pipeId?: number;
+	/**
+	 * transport configs
+	 */
+	transport?: {
+		/**
+		 * transport type
+		 */
+		type?:
+			| "ipc"
+			| "websocket"
+			| {
+					new (options: TransportOptions): Transport;
+			  };
+		/**
+		 * ipc transport's path list
+		 */
+		pathList?: PathData[];
+	};
 }
 export type ClientEvents = {
-    /**
-     * fired when the client is ready
-     */
-    ready: [];
-    /**
-     * fired when the client is connected to local rpc server
-     */
-    connected: [];
-    /**
-     * fired when the client is disconnected from the local rpc server
-     */
-    disconnected: [];
-    /**
-     * fired when the client is have debug message
-     */
-    debug: [...data: any];
+	/**
+	 * fired when the client is ready
+	 */
+	ready: [];
+	/**
+	 * fired when the client is connected to local rpc server
+	 */
+	connected: [];
+	/**
+	 * fired when the client is disconnected from the local rpc server
+	 */
+	disconnected: [];
+	/**
+	 * fired when the client is have debug message
+	 */
+	debug: [...data: any];
 } & {
-    [K in Exclude<RPC_EVT, "READY">]: [unknown];
+	[K in Exclude<RPC_EVT, "READY">]: [unknown];
 };
 export declare class Client extends AsyncEventEmitter<ClientEvents> {
-    #private;
-    /**
-     * application id
-     */
-    clientId: string;
-    /**
-     * application secret
-     */
-    clientSecret?: string;
-    /**
-     * pipe id
-     */
-    pipeId?: number;
-    get user(): ClientUser | undefined;
-    get application(): APIApplication | undefined;
-    get transport(): Transport;
-    get isConnected(): boolean;
-    constructor(options: ClientOptions);
-    /**
-     * @hidden
-     */
-    request<A = any, D = any>(cmd: RPC_CMD, args?: any, evt?: RPC_EVT): Promise<CommandIncoming<A, D>>;
-    private authenticate;
-    private refreshAccessToken;
-    private hanleAccessTokenResponse;
-    private authorize;
-    /**
-     * Used to subscribe to events. `evt` of the payload should be set to the event being subscribed to. `args` of the payload should be set to the args needed for the event.
-     * @param event event name now subscribed to
-     * @param args args for the event
-     * @returns an object to unsubscribe from the event
-     */
-    subscribe(event: Exclude<RPC_EVT, "READY" | "ERROR">, args?: any): Promise<{
-        unsubscribe: () => void;
-    }>;
-    /**
-     * connect to the local rpc server
-     */
-    connect(): Promise<void>;
-    /**
-     * will try to authorize if a scope is specified, else it's the same as `connect()`
-     * @param options options for the authorization
-     */
-    login(options?: AuthorizeOptions): Promise<void>;
-    /**
-     * disconnects from the local rpc server
-     */
-    destroy(): Promise<void>;
-    getCdn(): import("@discordjs/rest").CDN;
+	#private;
+	/**
+	 * application id
+	 */
+	clientId: string;
+	/**
+	 * application secret
+	 */
+	clientSecret?: string;
+	/**
+	 * pipe id
+	 */
+	pipeId?: number;
+	get user(): ClientUser | undefined;
+	get application(): APIApplication | undefined;
+	get transport(): Transport;
+	get isConnected(): boolean;
+	constructor(options: ClientOptions);
+	/**
+	 * @hidden
+	 */
+	request<A = any, D = any>(
+		cmd: RPC_CMD,
+		args?: any,
+		evt?: RPC_EVT,
+	): Promise<CommandIncoming<A, D>>;
+	authenticate;
+	private refreshAccessToken;
+	private hanleAccessTokenResponse;
+	private authorize;
+	/**
+	 * Used to subscribe to events. `evt` of the payload should be set to the event being subscribed to. `args` of the payload should be set to the args needed for the event.
+	 * @param event event name now subscribed to
+	 * @param args args for the event
+	 * @returns an object to unsubscribe from the event
+	 */
+	subscribe(
+		event: Exclude<RPC_EVT, "READY" | "ERROR">,
+		args?: any,
+	): Promise<{
+		unsubscribe: () => void;
+	}>;
+	/**
+	 * connect to the local rpc server
+	 */
+	connect(): Promise<void>;
+	/**
+	 * will try to authorize if a scope is specified, else it's the same as `connect()`
+	 * @param options options for the authorization
+	 */
+	login(options?: AuthorizeOptions): Promise<void>;
+	/**
+	 * disconnects from the local rpc server
+	 */
+	destroy(): Promise<void>;
+	getCdn(): import("@discordjs/rest").CDN;
 }
diff --git a/dist/Client.js b/dist/Client.js
index 326b8dad94026ce846fbec7905ddf560b4833353..3379a4c6c052543885c0fed8aa8fe1e3430cb429 100644
--- a/dist/Client.js
+++ b/dist/Client.js
@@ -1,19 +1,61 @@
 "use strict";
-var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
-    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
-    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
-    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
-};
-var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
-    if (kind === "m") throw new TypeError("Private method is not writable");
-    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
-    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
-    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
-};
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-var _Client_refreshToken, _Client_transport, _Client_user, _Client_application, _Client_rest, _Client_refreshTimeout, _Client_connectionPromise, _Client__nonceMap;
+var __classPrivateFieldGet =
+	(this && this.__classPrivateFieldGet) ||
+	function (receiver, state, kind, f) {
+		if (kind === "a" && !f)
+			throw new TypeError("Private accessor was defined without a getter");
+		if (
+			typeof state === "function"
+				? receiver !== state || !f
+				: !state.has(receiver)
+		)
+			throw new TypeError(
+				"Cannot read private member from an object whose class did not declare it",
+			);
+		return kind === "m"
+			? f
+			: kind === "a"
+				? f.call(receiver)
+				: f
+					? f.value
+					: state.get(receiver);
+	};
+var __classPrivateFieldSet =
+	(this && this.__classPrivateFieldSet) ||
+	function (receiver, state, value, kind, f) {
+		if (kind === "m") throw new TypeError("Private method is not writable");
+		if (kind === "a" && !f)
+			throw new TypeError("Private accessor was defined without a setter");
+		if (
+			typeof state === "function"
+				? receiver !== state || !f
+				: !state.has(receiver)
+		)
+			throw new TypeError(
+				"Cannot write private member to an object whose class did not declare it",
+			);
+		return (
+			kind === "a"
+				? f.call(receiver, value)
+				: f
+					? (f.value = value)
+					: state.set(receiver, value),
+			value
+		);
+	};
+var __importDefault =
+	(this && this.__importDefault) ||
+	function (mod) {
+		return mod && mod.__esModule ? mod : { default: mod };
+	};
+var _Client_refreshToken,
+	_Client_transport,
+	_Client_user,
+	_Client_application,
+	_Client_rest,
+	_Client_refreshTimeout,
+	_Client_connectionPromise,
+	_Client__nonceMap;
 Object.defineProperty(exports, "__esModule", { value: true });
 exports.Client = void 0;
 const v10_1 = require("discord-api-types/v10");
@@ -26,275 +68,388 @@ const rest_1 = require("@discordjs/rest");
 const node_crypto_1 = __importDefault(require("node:crypto"));
 const Transport_1 = require("./structures/Transport");
 class Client extends async_event_emitter_1.AsyncEventEmitter {
-    get user() {
-        return __classPrivateFieldGet(this, _Client_user, "f");
-    }
-    get application() {
-        return __classPrivateFieldGet(this, _Client_application, "f");
-    }
-    get transport() {
-        return __classPrivateFieldGet(this, _Client_transport, "f");
-    }
-    get isConnected() {
-        return __classPrivateFieldGet(this, _Client_transport, "f").isConnected;
-    }
-    constructor(options) {
-        super();
-        /**
-         * application id
-         */
-        Object.defineProperty(this, "clientId", {
-            enumerable: true,
-            configurable: true,
-            writable: true,
-            value: void 0
-        });
-        /**
-         * application secret
-         */
-        Object.defineProperty(this, "clientSecret", {
-            enumerable: true,
-            configurable: true,
-            writable: true,
-            value: void 0
-        });
-        /**
-         * pipe id
-         */
-        Object.defineProperty(this, "pipeId", {
-            enumerable: true,
-            configurable: true,
-            writable: true,
-            value: void 0
-        });
-        _Client_refreshToken.set(this, void 0);
-        /**
-         * transport instance
-         */
-        _Client_transport.set(this, void 0);
-        /**
-         * current user
-         */
-        _Client_user.set(this, void 0);
-        /**
-         * current application
-         */
-        _Client_application.set(this, void 0);
-        _Client_rest.set(this, void 0);
-        _Client_refreshTimeout.set(this, void 0);
-        _Client_connectionPromise.set(this, void 0);
-        _Client__nonceMap.set(this, new Map());
-        this.clientId = options.clientId;
-        this.clientSecret = options.clientSecret;
-        this.pipeId = options.pipeId;
-        __classPrivateFieldSet(this, _Client_rest, new rest_1.REST({ version: "10" }).setToken("this-is-a-dummy"), "f");
-        __classPrivateFieldSet(this, _Client_transport, options.transport?.type === undefined || options.transport.type === "ipc"
-            ? new IPC_1.IPCTransport({
-                client: this,
-                pathList: options.transport?.pathList
-            })
-            : new (options.transport.type === "websocket" ? WebSocket_1.WebSocketTransport : options.transport.type)({
-                client: this
-            }), "f");
-        __classPrivateFieldGet(this, _Client_transport, "f").on("message", (message) => {
-            if (message.cmd === "DISPATCH" && message.evt === "READY") {
-                if (message.data.user)
-                    __classPrivateFieldSet(this, _Client_user, new ClientUser_1.ClientUser(this, message.data.user), "f");
-                if (message.data.config && message.data.config.cdn_host)
-                    __classPrivateFieldGet(this, _Client_rest, "f").options.cdn = message.data.config.cdn_host;
-                this.emit("connected");
-            }
-            else {
-                if (message.nonce && __classPrivateFieldGet(this, _Client__nonceMap, "f").has(message.nonce)) {
-                    const nonceObj = __classPrivateFieldGet(this, _Client__nonceMap, "f").get(message.nonce);
-                    if (message.evt === "ERROR") {
-                        nonceObj.error.code = message.data.code;
-                        nonceObj.error.message = message.data.message;
-                        nonceObj?.reject(nonceObj.error);
-                    }
-                    else
-                        nonceObj?.resolve(message);
-                    __classPrivateFieldGet(this, _Client__nonceMap, "f").delete(message.nonce);
-                }
-                this.emit(message.evt, message.data);
-            }
-        });
-    }
-    /**
-     * @hidden
-     */
-    async request(cmd, args, evt) {
-        const error = new RPCError_1.RPCError(Transport_1.RPC_ERROR_CODE.UNKNOWN_ERROR);
-        RPCError_1.RPCError.captureStackTrace(error, this.request);
-        return new Promise((resolve, reject) => {
-            const nonce = node_crypto_1.default.randomUUID();
-            __classPrivateFieldGet(this, _Client_transport, "f").send({ cmd, args, evt, nonce });
-            __classPrivateFieldGet(this, _Client__nonceMap, "f").set(nonce, { resolve, reject, error });
-        });
-    }
-    // #endregion
-    // #region Authorization handlers
-    async authenticate(accessToken) {
-        const { application, user } = (await this.request("AUTHENTICATE", { access_token: accessToken })).data;
-        __classPrivateFieldSet(this, _Client_application, application, "f");
-        __classPrivateFieldSet(this, _Client_user, new ClientUser_1.ClientUser(this, user), "f");
-        this.emit("ready");
-    }
-    async refreshAccessToken() {
-        this.emit("debug", "CLIENT | Refreshing access token!");
-        const exchangeResponse = await __classPrivateFieldGet(this, _Client_rest, "f").post(v10_1.Routes.oauth2TokenExchange(), {
-            body: new URLSearchParams({
-                client_id: this.clientId,
-                client_secret: this.clientSecret ?? "",
-                grant_type: "refresh_token",
-                refresh_token: __classPrivateFieldGet(this, _Client_refreshToken, "f") ?? ""
-            }),
-            headers: {
-                "content-type": "application/x-www-form-urlencoded"
-            },
-            passThroughBody: true
-        });
-        this.hanleAccessTokenResponse(exchangeResponse);
-        this.emit("debug", "CLIENT | Access token refreshed!");
-        return exchangeResponse.access_token;
-    }
-    hanleAccessTokenResponse(data) {
-        if (!("access_token" in data) ||
-            !("refresh_token" in data) ||
-            !("expires_in" in data) ||
-            !("token_type" in data))
-            throw new TypeError(`Invalid access token response!\nData: ${JSON.stringify(data, null, 2)}`);
-        __classPrivateFieldGet(this, _Client_rest, "f").setToken(data.access_token);
-        __classPrivateFieldGet(this, _Client_rest, "f").options.authPrefix = data.token_type;
-        __classPrivateFieldSet(this, _Client_refreshToken, data.refresh_token, "f");
-        __classPrivateFieldSet(this, _Client_refreshTimeout, setTimeout(() => void this.refreshAccessToken(), data.expires_in), "f");
-    }
-    async authorize(options) {
-        if (!this.clientSecret)
-            throw new ReferenceError("Client secret is required for authorization!");
-        let rpcToken;
-        if (options.useRPCToken) {
-            rpcToken = // Sadly discord-api-types doesn't have the oauth2/token/rpc endpoint
-                (await __classPrivateFieldGet(this, _Client_rest, "f").post("/oauth2/token/rpc", {
-                    body: new URLSearchParams({
-                        client_id: this.clientId,
-                        client_secret: this.clientSecret
-                    }),
-                    headers: {
-                        "content-type": "application/x-www-form-urlencoded"
-                    }
-                })).rpc_token;
-        }
-        const { code } = (await this.request("AUTHORIZE", {
-            scopes: options.scopes,
-            client_id: this.clientId,
-            rpc_token: options.useRPCToken ? rpcToken : undefined,
-            prompt: options.prompt ?? "consent"
-        })).data;
-        const exchangeResponse = await __classPrivateFieldGet(this, _Client_rest, "f").post(v10_1.Routes.oauth2TokenExchange(), {
-            body: new URLSearchParams({
-                client_id: this.clientId,
-                client_secret: this.clientSecret,
-                grant_type: "authorization_code",
-                code
-            }),
-            headers: {
-                "content-type": "application/x-www-form-urlencoded"
-            },
-            passThroughBody: true
-        });
-        this.hanleAccessTokenResponse(exchangeResponse);
-        return exchangeResponse.access_token;
-    }
-    // #endregion
-    /**
-     * Used to subscribe to events. `evt` of the payload should be set to the event being subscribed to. `args` of the payload should be set to the args needed for the event.
-     * @param event event name now subscribed to
-     * @param args args for the event
-     * @returns an object to unsubscribe from the event
-     */
-    async subscribe(event, args) {
-        await this.request("SUBSCRIBE", args, event);
-        return {
-            /**
-             * Unsubscribes from the event
-             */
-            unsubscribe: () => this.request("UNSUBSCRIBE", args, event)
-        };
-    }
-    ///////////////////////////////////////////////////////////////////////////////////////////////////////////
-    /**
-     * connect to the local rpc server
-     */
-    async connect() {
-        if (__classPrivateFieldGet(this, _Client_connectionPromise, "f"))
-            return __classPrivateFieldGet(this, _Client_connectionPromise, "f");
-        const error = new RPCError_1.RPCError(Transport_1.RPC_ERROR_CODE.UNKNOWN_ERROR);
-        RPCError_1.RPCError.captureStackTrace(error, this.connect);
-        __classPrivateFieldSet(this, _Client_connectionPromise, new Promise((resolve, reject) => {
-            const timeout = setTimeout(() => {
-                __classPrivateFieldSet(this, _Client_connectionPromise, undefined, "f");
-                error.code = Transport_1.CUSTOM_RPC_ERROR_CODE.CONNECTION_TIMEOUT;
-                error.message = "Connection timed out";
-                reject(error);
-            }, 10e3);
-            if (typeof timeout === "object" && "unref" in timeout)
-                timeout.unref();
-            this.once("connected", () => {
-                __classPrivateFieldSet(this, _Client_connectionPromise, undefined, "f");
-                __classPrivateFieldGet(this, _Client_transport, "f").once("close", (reason) => {
-                    __classPrivateFieldGet(this, _Client__nonceMap, "f").forEach((promise) => {
-                        promise.error.code =
-                            typeof reason === "object" ? reason.code : Transport_1.CUSTOM_RPC_ERROR_CODE.CONNECTION_ENDED;
-                        promise.error.message =
-                            typeof reason === "object" ? reason.message : (reason ?? "Connection ended");
-                        promise.reject(promise.error);
-                    });
-                    this.emit("disconnected");
-                });
-                clearTimeout(timeout);
-                resolve();
-            });
-            __classPrivateFieldGet(this, _Client_transport, "f").connect().catch(reject);
-        }), "f");
-        return __classPrivateFieldGet(this, _Client_connectionPromise, "f");
-    }
-    /**
-     * will try to authorize if a scope is specified, else it's the same as `connect()`
-     * @param options options for the authorization
-     */
-    async login(options) {
-        await this.connect();
-        if (!options || !options.scopes) {
-            this.emit("ready");
-            return;
-        }
-        let accessToken = "";
-        if (options.refreshToken) {
-            __classPrivateFieldSet(this, _Client_refreshToken, options.refreshToken, "f");
-            accessToken = await this.refreshAccessToken();
-        }
-        else {
-            if (!this.clientSecret)
-                throw new ReferenceError("Client secret is required for authorization!");
-            accessToken = await this.authorize(options);
-        }
-        await this.authenticate(accessToken);
-    }
-    /**
-     * disconnects from the local rpc server
-     */
-    async destroy() {
-        if (__classPrivateFieldGet(this, _Client_refreshTimeout, "f")) {
-            clearTimeout(__classPrivateFieldGet(this, _Client_refreshTimeout, "f"));
-            __classPrivateFieldSet(this, _Client_refreshTimeout, undefined, "f");
-            __classPrivateFieldSet(this, _Client_refreshToken, undefined, "f");
-        }
-        await __classPrivateFieldGet(this, _Client_transport, "f").close();
-    }
-    getCdn() {
-        return __classPrivateFieldGet(this, _Client_rest, "f").cdn;
-    }
+	get user() {
+		return __classPrivateFieldGet(this, _Client_user, "f");
+	}
+	get application() {
+		return __classPrivateFieldGet(this, _Client_application, "f");
+	}
+	get transport() {
+		return __classPrivateFieldGet(this, _Client_transport, "f");
+	}
+	get isConnected() {
+		return __classPrivateFieldGet(this, _Client_transport, "f").isConnected;
+	}
+	constructor(options) {
+		super();
+		/**
+		 * application id
+		 */
+		Object.defineProperty(this, "clientId", {
+			enumerable: true,
+			configurable: true,
+			writable: true,
+			value: void 0,
+		});
+		/**
+		 * application secret
+		 */
+		Object.defineProperty(this, "clientSecret", {
+			enumerable: true,
+			configurable: true,
+			writable: true,
+			value: void 0,
+		});
+		/**
+		 * pipe id
+		 */
+		Object.defineProperty(this, "pipeId", {
+			enumerable: true,
+			configurable: true,
+			writable: true,
+			value: void 0,
+		});
+		_Client_refreshToken.set(this, void 0);
+		/**
+		 * transport instance
+		 */
+		_Client_transport.set(this, void 0);
+		/**
+		 * current user
+		 */
+		_Client_user.set(this, void 0);
+		/**
+		 * current application
+		 */
+		_Client_application.set(this, void 0);
+		_Client_rest.set(this, void 0);
+		_Client_refreshTimeout.set(this, void 0);
+		_Client_connectionPromise.set(this, void 0);
+		_Client__nonceMap.set(this, new Map());
+		this.clientId = options.clientId;
+		this.clientSecret = options.clientSecret;
+		this.pipeId = options.pipeId;
+		__classPrivateFieldSet(
+			this,
+			_Client_rest,
+			new rest_1.REST({ version: "10" }).setToken("this-is-a-dummy"),
+			"f",
+		);
+		__classPrivateFieldSet(
+			this,
+			_Client_transport,
+			options.transport?.type === undefined || options.transport.type === "ipc"
+				? new IPC_1.IPCTransport({
+						client: this,
+						pathList: options.transport?.pathList,
+					})
+				: new (options.transport.type === "websocket"
+						? WebSocket_1.WebSocketTransport
+						: options.transport.type)({
+						client: this,
+					}),
+			"f",
+		);
+		__classPrivateFieldGet(this, _Client_transport, "f").on(
+			"message",
+			(message) => {
+				if (message.cmd === "DISPATCH" && message.evt === "READY") {
+					if (message.data.user)
+						__classPrivateFieldSet(
+							this,
+							_Client_user,
+							new ClientUser_1.ClientUser(this, message.data.user),
+							"f",
+						);
+					if (message.data.config && message.data.config.cdn_host)
+						__classPrivateFieldGet(this, _Client_rest, "f").options.cdn =
+							message.data.config.cdn_host;
+					this.emit("connected");
+				} else {
+					if (
+						message.nonce &&
+						__classPrivateFieldGet(this, _Client__nonceMap, "f").has(
+							message.nonce,
+						)
+					) {
+						const nonceObj = __classPrivateFieldGet(
+							this,
+							_Client__nonceMap,
+							"f",
+						).get(message.nonce);
+						if (message.evt === "ERROR") {
+							nonceObj.error.code = message.data.code;
+							nonceObj.error.message = message.data.message;
+							nonceObj?.reject(nonceObj.error);
+						} else nonceObj?.resolve(message);
+						__classPrivateFieldGet(this, _Client__nonceMap, "f").delete(
+							message.nonce,
+						);
+					}
+					this.emit(message.evt, message.data);
+				}
+			},
+		);
+	}
+	/**
+	 * @hidden
+	 */
+	async request(cmd, args, evt) {
+		const error = new RPCError_1.RPCError(
+			Transport_1.RPC_ERROR_CODE.UNKNOWN_ERROR,
+		);
+		RPCError_1.RPCError.captureStackTrace(error, this.request);
+		return new Promise((resolve, reject) => {
+			const nonce = node_crypto_1.default.randomUUID();
+			__classPrivateFieldGet(this, _Client_transport, "f").send({
+				cmd,
+				args,
+				evt,
+				nonce,
+			});
+			__classPrivateFieldGet(this, _Client__nonceMap, "f").set(nonce, {
+				resolve,
+				reject,
+				error,
+			});
+		});
+	}
+	// #endregion
+	// #region Authorization handlers
+	async authenticate(accessToken) {
+		const { application, user } = (
+			await this.request("AUTHENTICATE", { access_token: accessToken })
+		).data;
+		__classPrivateFieldSet(this, _Client_application, application, "f");
+		__classPrivateFieldSet(
+			this,
+			_Client_user,
+			new ClientUser_1.ClientUser(this, user),
+			"f",
+		);
+		this.emit("ready");
+	}
+	async refreshAccessToken() {
+		this.emit("debug", "CLIENT | Refreshing access token!");
+		const exchangeResponse = await __classPrivateFieldGet(
+			this,
+			_Client_rest,
+			"f",
+		).post(v10_1.Routes.oauth2TokenExchange(), {
+			body: new URLSearchParams({
+				client_id: this.clientId,
+				client_secret: this.clientSecret ?? "",
+				grant_type: "refresh_token",
+				refresh_token:
+					__classPrivateFieldGet(this, _Client_refreshToken, "f") ?? "",
+			}),
+			headers: {
+				"content-type": "application/x-www-form-urlencoded",
+			},
+			passThroughBody: true,
+		});
+		this.hanleAccessTokenResponse(exchangeResponse);
+		this.emit("debug", "CLIENT | Access token refreshed!");
+		return exchangeResponse.access_token;
+	}
+	hanleAccessTokenResponse(data) {
+		if (
+			!("access_token" in data) ||
+			!("refresh_token" in data) ||
+			!("expires_in" in data) ||
+			!("token_type" in data)
+		)
+			throw new TypeError(
+				`Invalid access token response!\nData: ${JSON.stringify(data, null, 2)}`,
+			);
+		__classPrivateFieldGet(this, _Client_rest, "f").setToken(data.access_token);
+		__classPrivateFieldGet(this, _Client_rest, "f").options.authPrefix =
+			data.token_type;
+		__classPrivateFieldSet(this, _Client_refreshToken, data.refresh_token, "f");
+		__classPrivateFieldSet(
+			this,
+			_Client_refreshTimeout,
+			setTimeout(() => void this.refreshAccessToken(), data.expires_in),
+			"f",
+		);
+	}
+	async authorize(options) {
+		if (!this.clientSecret)
+			throw new ReferenceError("Client secret is required for authorization!");
+		let rpcToken;
+		if (options.useRPCToken) {
+			rpcToken = // Sadly discord-api-types doesn't have the oauth2/token/rpc endpoint
+				(
+					await __classPrivateFieldGet(this, _Client_rest, "f").post(
+						"/oauth2/token/rpc",
+						{
+							body: new URLSearchParams({
+								client_id: this.clientId,
+								client_secret: this.clientSecret,
+							}),
+							headers: {
+								"content-type": "application/x-www-form-urlencoded",
+							},
+						},
+					)
+				).rpc_token;
+		}
+		const { code } = (
+			await this.request("AUTHORIZE", {
+				scopes: options.scopes,
+				client_id: this.clientId,
+				rpc_token: options.useRPCToken ? rpcToken : undefined,
+				prompt: options.prompt ?? "consent",
+			})
+		).data;
+		const exchangeResponse = await __classPrivateFieldGet(
+			this,
+			_Client_rest,
+			"f",
+		).post(v10_1.Routes.oauth2TokenExchange(), {
+			body: new URLSearchParams({
+				client_id: this.clientId,
+				client_secret: this.clientSecret,
+				grant_type: "authorization_code",
+				code,
+			}),
+			headers: {
+				"content-type": "application/x-www-form-urlencoded",
+			},
+			passThroughBody: true,
+		});
+		this.hanleAccessTokenResponse(exchangeResponse);
+		return exchangeResponse.access_token;
+	}
+	// #endregion
+	/**
+	 * Used to subscribe to events. `evt` of the payload should be set to the event being subscribed to. `args` of the payload should be set to the args needed for the event.
+	 * @param event event name now subscribed to
+	 * @param args args for the event
+	 * @returns an object to unsubscribe from the event
+	 */
+	async subscribe(event, args) {
+		await this.request("SUBSCRIBE", args, event);
+		return {
+			/**
+			 * Unsubscribes from the event
+			 */
+			unsubscribe: () => this.request("UNSUBSCRIBE", args, event),
+		};
+	}
+	///////////////////////////////////////////////////////////////////////////////////////////////////////////
+	/**
+	 * connect to the local rpc server
+	 */
+	async connect() {
+		if (__classPrivateFieldGet(this, _Client_connectionPromise, "f"))
+			return __classPrivateFieldGet(this, _Client_connectionPromise, "f");
+		const error = new RPCError_1.RPCError(
+			Transport_1.RPC_ERROR_CODE.UNKNOWN_ERROR,
+		);
+		RPCError_1.RPCError.captureStackTrace(error, this.connect);
+		__classPrivateFieldSet(
+			this,
+			_Client_connectionPromise,
+			new Promise((resolve, reject) => {
+				const timeout = setTimeout(() => {
+					__classPrivateFieldSet(
+						this,
+						_Client_connectionPromise,
+						undefined,
+						"f",
+					);
+					error.code = Transport_1.CUSTOM_RPC_ERROR_CODE.CONNECTION_TIMEOUT;
+					error.message = "Connection timed out";
+					reject(error);
+				}, 10e3);
+				if (typeof timeout === "object" && "unref" in timeout) timeout.unref();
+				this.once("connected", () => {
+					__classPrivateFieldSet(
+						this,
+						_Client_connectionPromise,
+						undefined,
+						"f",
+					);
+					__classPrivateFieldGet(this, _Client_transport, "f").once(
+						"close",
+						(reason) => {
+							__classPrivateFieldGet(this, _Client__nonceMap, "f").forEach(
+								(promise) => {
+									promise.error.code =
+										typeof reason === "object"
+											? reason.code
+											: Transport_1.CUSTOM_RPC_ERROR_CODE.CONNECTION_ENDED;
+									promise.error.message =
+										typeof reason === "object"
+											? reason.message
+											: (reason ?? "Connection ended");
+									promise.reject(promise.error);
+								},
+							);
+							this.emit("disconnected");
+						},
+					);
+					clearTimeout(timeout);
+					resolve();
+				});
+				__classPrivateFieldGet(this, _Client_transport, "f")
+					.connect()
+					.catch(reject);
+			}),
+			"f",
+		);
+		return __classPrivateFieldGet(this, _Client_connectionPromise, "f");
+	}
+	/**
+	 * will try to authorize if a scope is specified, else it's the same as `connect()`
+	 * @param options options for the authorization
+	 */
+	async login(options) {
+		await this.connect();
+		if (!options || !options.scopes) {
+			this.emit("ready");
+			return;
+		}
+		let accessToken = "";
+		if (options.refreshToken) {
+			__classPrivateFieldSet(
+				this,
+				_Client_refreshToken,
+				options.refreshToken,
+				"f",
+			);
+			accessToken = await this.refreshAccessToken();
+		} else {
+			if (!this.clientSecret)
+				throw new ReferenceError(
+					"Client secret is required for authorization!",
+				);
+			accessToken = await this.authorize(options);
+		}
+		await this.authenticate(accessToken);
+	}
+	/**
+	 * disconnects from the local rpc server
+	 */
+	async destroy() {
+		if (__classPrivateFieldGet(this, _Client_refreshTimeout, "f")) {
+			clearTimeout(__classPrivateFieldGet(this, _Client_refreshTimeout, "f"));
+			__classPrivateFieldSet(this, _Client_refreshTimeout, undefined, "f");
+			__classPrivateFieldSet(this, _Client_refreshToken, undefined, "f");
+		}
+		await __classPrivateFieldGet(this, _Client_transport, "f").close();
+	}
+	getCdn() {
+		return __classPrivateFieldGet(this, _Client_rest, "f").cdn;
+	}
 }
 exports.Client = Client;
-_Client_refreshToken = new WeakMap(), _Client_transport = new WeakMap(), _Client_user = new WeakMap(), _Client_application = new WeakMap(), _Client_rest = new WeakMap(), _Client_refreshTimeout = new WeakMap(), _Client_connectionPromise = new WeakMap(), _Client__nonceMap = new WeakMap();
+(_Client_refreshToken = new WeakMap()),
+	(_Client_transport = new WeakMap()),
+	(_Client_user = new WeakMap()),
+	(_Client_application = new WeakMap()),
+	(_Client_rest = new WeakMap()),
+	(_Client_refreshTimeout = new WeakMap()),
+	(_Client_connectionPromise = new WeakMap()),
+	(_Client__nonceMap = new WeakMap());
diff --git a/dist/structures/ClientUser.js b/dist/structures/ClientUser.js
index 7976fd675376c0b21d310a8ed21e1c66269edab0..af8e106f1184d2f5acab62f5714e1eb7f3431f8f 100644
--- a/dist/structures/ClientUser.js
+++ b/dist/structures/ClientUser.js
@@ -1,472 +1,599 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
-exports.ClientUser = exports.ActivityPartyPrivacy = exports.ActivitySupportedPlatform = void 0;
+exports.ClientUser =
+	exports.ActivityPartyPrivacy =
+	exports.ActivitySupportedPlatform =
+		void 0;
 const VoiceSettings_1 = require("./VoiceSettings");
 const Channel_1 = require("./Channel");
 const Guild_1 = require("./Guild");
 const User_1 = require("./User");
 var ActivitySupportedPlatform;
 (function (ActivitySupportedPlatform) {
-    ActivitySupportedPlatform["IOS"] = "ios";
-    ActivitySupportedPlatform["ANDROID"] = "android";
-    ActivitySupportedPlatform["WEB"] = "web";
-})(ActivitySupportedPlatform || (exports.ActivitySupportedPlatform = ActivitySupportedPlatform = {}));
+	ActivitySupportedPlatform["IOS"] = "ios";
+	ActivitySupportedPlatform["ANDROID"] = "android";
+	ActivitySupportedPlatform["WEB"] = "web";
+})(
+	ActivitySupportedPlatform ||
+		(exports.ActivitySupportedPlatform = ActivitySupportedPlatform = {}),
+);
 var ActivityPartyPrivacy;
 (function (ActivityPartyPrivacy) {
-    ActivityPartyPrivacy[ActivityPartyPrivacy["PRIVATE"] = 0] = "PRIVATE";
-    ActivityPartyPrivacy[ActivityPartyPrivacy["PUBLIC"] = 1] = "PUBLIC";
-})(ActivityPartyPrivacy || (exports.ActivityPartyPrivacy = ActivityPartyPrivacy = {}));
+	ActivityPartyPrivacy[(ActivityPartyPrivacy["PRIVATE"] = 0)] = "PRIVATE";
+	ActivityPartyPrivacy[(ActivityPartyPrivacy["PUBLIC"] = 1)] = "PUBLIC";
+})(
+	ActivityPartyPrivacy ||
+		(exports.ActivityPartyPrivacy = ActivityPartyPrivacy = {}),
+);
 class ClientUser extends User_1.User {
-    // #region Helper function
-    async fetchUser(userId) {
-        return new User_1.User(this.client, (await this.client.request("GET_USER", { id: userId })).data);
-    }
-    /**
-     * Used to get a guild the client is in.
-     *
-     * @param guildId - id of the guild to get
-     * @param timeout - asynchronously get guild with time to wait before timing out
-     * @returns partial guild
-     */
-    async fetchGuild(guildId, timeout) {
-        return new Guild_1.Guild(this.client, (await this.client.request("GET_GUILD", { guild_id: guildId, timeout })).data);
-    }
-    /**
-     * Used to get a list of guilds the client is in.
-     * @returns the guilds the user is in
-     */
-    async fetchGuilds() {
-        return (await this.client.request("GET_GUILDS")).data.guilds.map((guildData) => new Guild_1.Guild(this.client, guildData));
-    }
-    /**
-     * Used to get a channel the client is in.
-     * @param channelId - id of the channel to get
-     * @returns partial channel
-     */
-    async fetchChannel(channelId) {
-        return new Channel_1.Channel(this.client, (await this.client.request("GET_CHANNEL", { channel_id: channelId })).data);
-    }
-    /**
-     * Used to get a guild's channels the client is in.
-     * @param guildId - id of the guild to get channels for
-     * @returns guild channels the user is in
-     */
-    async fetchChannels(guildId) {
-        return (await this.client.request("GET_CHANNELS", { guild_id: guildId })).data.channels.map((channelData) => new Channel_1.Channel(this.client, channelData));
-    }
-    /**
-     * Used to get the client's current voice channel. There are no arguments for this command. Returns the [Get Channel](https://discord.com/developers/docs/topics/rpc#getchannel) response, or `null` if none.
-     * @returns the client's current voice channel, `null` if none
-     */
-    async getSelectedVoiceChannel() {
-        const response = await this.client.request("GET_SELECTED_VOICE_CHANNEL");
-        return response.data !== null ? new Channel_1.Channel(this.client, response.data) : null;
-    }
-    /**
-     * Used to join voice channels, group dms, or dms. Returns the [Get Channel](https://discord.com/developers/docs/topics/rpc#getchannel) response, `null` if none.
-     * @param channelId - channel id to join
-     * @param timeout - asynchronously join channel with time to wait before timing out
-     * @param force - forces a user to join a voice channel
-     * @returns the channel that the user joined, `null` if none
-     */
-    async selectVoiceChannel(channelId, timeout, force, navigate) {
-        return new Channel_1.Channel(this.client, (await this.client.request("SELECT_VOICE_CHANNEL", {
-            channel_id: channelId,
-            timeout,
-            force,
-            navigate
-        })).data);
-    }
-    /**
-     * Used to leave voice channels, group dms, or dms
-     * @param timeout - asynchronously join channel with time to wait before timing out
-     * @param force - forces a user to join a voice channel
-     */
-    async leaveVoiceChannel(timeout, force) {
-        await this.client.request("SELECT_VOICE_CHANNEL", {
-            channel_id: null,
-            timeout,
-            force
-        });
-    }
-    /**
-     * Used to get current client's voice settings
-     * @returns the voice setting
-     */
-    async getVoiceSettings() {
-        return new VoiceSettings_1.VoiceSettings(this.client, (await this.client.request("GET_VOICE_SETTINGS")).data);
-    }
-    /**
-     * Used by hardware manufacturers to send information about the current state of their certified devices that are connected to Discord.
-     * @param devices - a list of devices for your manufacturer, in order of priority
-     * @returns
-     */
-    async setCeritfiedDevices(devices) {
-        await this.client.request("SET_CERTIFIED_DEVICES", { devices });
-    }
-    /**
-     * Used to accept an Ask to Join request.
-     * @param userId - the id of the requesting user
-     */
-    async sendJoinInvite(userId) {
-        await this.client.request("SEND_ACTIVITY_JOIN_INVITE", { user_id: userId });
-    }
-    /**
-     * Used to reject an Ask to Join request.
-     * @param userId - the id of the requesting user
-     */
-    async closeJoinRequest(userId) {
-        await this.client.request("CLOSE_ACTIVITY_JOIN_REQUEST", { user_id: userId });
-    }
-    /**
-     * Used to join text channels, group dms, or dms. Returns the [Get Channel](https://discord.com/developers/docs/topics/rpc#getchannel) response, or `null` if none.
-     * @param channelId - channel id to join
-     * @param timeout - asynchronously join channel with time to wait before timing out
-     * @returns the text channel that user joined
-     */
-    async selectTextChannel(channelId, timeout) {
-        return new Channel_1.Channel(this.client, (await this.client.request("SELECT_TEXT_CHANNEL", { channel_id: channelId, timeout })).data);
-    }
-    /**
-     * Used to leave text channels, group dms, or dms.
-     * @param timeout - asynchronously join channel with time to wait before timing out
-     */
-    async leaveTextChannel(timeout) {
-        await this.client.request("SELECT_TEXT_CHANNEL", { channel_id: null, timeout });
-    }
-    async getRelationships() {
-        return (await this.client.request("GET_RELATIONSHIPS")).data.relationships.map((data) => {
-            return new User_1.User(this.client, { ...data.user, presence: data.presence });
-        });
-    }
-    /**
-     * Used to update a user's Rich Presence.
-     *
-     * @param activity - the rich presence to assign to the user
-     * @param pid - the application's process id
-     * @returns The activity that have been set
-     */
-    async setActivity(activity, pid) {
-        const formattedAcitivity = {
-            ...activity,
-            assets: {},
-            timestamps: {},
-            party: {},
-            secrets: {}
-        };
-        if (activity.startTimestamp instanceof Date) {
-            formattedAcitivity.timestamps.start = Math.round(activity.startTimestamp.getTime());
-        }
-        else if (typeof activity.startTimestamp === "number") {
-            formattedAcitivity.timestamps.start = activity.startTimestamp;
-        }
-        if (activity.endTimestamp instanceof Date) {
-            formattedAcitivity.timestamps.end = Math.round(activity.endTimestamp.getTime());
-        }
-        else if (typeof activity.endTimestamp === "number") {
-            formattedAcitivity.timestamps.end = activity.endTimestamp;
-        }
-        if (activity.largeImageKey)
-            formattedAcitivity.assets.large_image = activity.largeImageKey;
-        if (activity.smallImageKey)
-            formattedAcitivity.assets.small_image = activity.smallImageKey;
-        if (activity.largeImageText)
-            formattedAcitivity.assets.large_text = activity.largeImageText;
-        if (activity.smallImageText)
-            formattedAcitivity.assets.small_text = activity.smallImageText;
-        if (activity.partyId)
-            formattedAcitivity.party.id = activity.partyId;
-        if (activity.partyPrivacy)
-            formattedAcitivity.party.privacy = activity.partyPrivacy;
-        if (activity.partySize && activity.partyMax)
-            formattedAcitivity.party.size = [activity.partySize, activity.partyMax];
-        if (activity.joinSecret)
-            formattedAcitivity.secrets.join = activity.joinSecret;
-        if (activity.spectateSecret)
-            formattedAcitivity.secrets.spectate = activity.spectateSecret;
-        if (activity.matchSecret)
-            formattedAcitivity.secrets.match = activity.matchSecret;
-        if (activity.supportedPlatforms)
-            formattedAcitivity.supported_platforms = activity.supportedPlatforms;
-        if (Object.keys(formattedAcitivity.assets).length === 0)
-            delete formattedAcitivity["assets"];
-        if (Object.keys(formattedAcitivity.timestamps).length === 0)
-            delete formattedAcitivity["timestamps"];
-        if (Object.keys(formattedAcitivity.party).length === 0)
-            delete formattedAcitivity["party"];
-        if (Object.keys(formattedAcitivity.secrets).length === 0)
-            delete formattedAcitivity["secrets"];
-        formattedAcitivity.instance = !!activity.instance;
-        // Clean-up
-        delete formattedAcitivity["startTimestamp"];
-        delete formattedAcitivity["endTimestamp"];
-        delete formattedAcitivity["largeImageKey"];
-        delete formattedAcitivity["smallImageKey"];
-        delete formattedAcitivity["largeImageText"];
-        delete formattedAcitivity["smallImageText"];
-        delete formattedAcitivity["partyId"];
-        delete formattedAcitivity["partyPrivacy"];
-        delete formattedAcitivity["partySize"];
-        delete formattedAcitivity["partyMax"];
-        delete formattedAcitivity["joinSecret"];
-        delete formattedAcitivity["spectateSecret"];
-        delete formattedAcitivity["matchSecret"];
-        delete formattedAcitivity["supportedPlatforms"];
-        return (await this.client.request("SET_ACTIVITY", {
-            pid: (pid ?? process) ? (process.pid ?? 0) : 0,
-            activity: formattedAcitivity
-        })).data;
-    }
-    /**
-     * Used to clear a user's Rich Presence.
-     *
-     * @param pid - the application's process id
-     */
-    async clearActivity(pid) {
-        await this.client.request("SET_ACTIVITY", { pid: (pid ?? process) ? (process.pid ?? 0) : 0 });
-    }
-    // #region Undocumented
-    // This region holds method that are not documented by Discord BUT does exist
-    // Also most of this might not even be correct, use at your own risk
-    /**
-     * Used to get a user's avatar
-     * @param userId - id of the user to get the avatar of
-     * @param format - image format
-     * @param size - image size
-     * @return base64 encoded image data
-     */
-    async getImage(userId, format = "png", size = 1024) {
-        return (await this.client.request("GET_IMAGE", { type: "user", id: userId, format, size })).data.data_url;
-    }
-    /**
-     * Requires RPC and RPC_VOICE_WRITE
-     * @returns
-     */
-    async getSoundboardSounds() {
-        return (await this.client.request("GET_SOUNDBOARD_SOUNDS")).data;
-    }
-    /**
-     * Requires RPC and RPC_VOICE_WRITE
-     * @returns
-     */
-    async playSoundboardSound(guildId, soundId) {
-        return (await this.client.request("PLAY_SOUNDBOARD_SOUND", {
-            guild_id: guildId,
-            sound_id: soundId
-        })).data;
-    }
-    /**
-     * Requires RPC and RPC_VIDEO_WRITE
-     * @returns
-     */
-    async toggleVideo() {
-        return (await this.client.request("TOGGLE_VIDEO")).data;
-    }
-    /**
-     * Requires RPC and RPC_SCREENSHARE_WRITE
-     * @returns
-     */
-    async toggleScreenshare(pid) {
-        return (await this.client.request("TOGGLE_SCREENSHARE", { pid })).data;
-    }
-    /**
-     * Requires RPC and RPC_VOICE_WRITE
-     * @returns
-     */
-    async setPushToTalk(active) {
-        return (await this.client.request("PUSH_TO_TALK", { active })).data;
-    }
-    /**
-     * Requires RPC and RPC_VOICE_WRITE
-     * @returns
-     */
-    async setVoiceSettings(req) {
-        return (await this.client.request("SET_VOICE_SETTINGS", req)).data;
-    }
-    /**
-     * Requires RPC and RPC_VOICE_WRITE
-     * @returns
-     */
-    async setVoiceSettings2(req) {
-        return (await this.client.request("SET_VOICE_SETTINGS_2", req)).data;
-    }
-    /**
-     * Requires RPC and RPC_GUILDS_MEMBERS_READ
-     * @returns
-     */
-    async getChannelPermissions() {
-        return (await this.client.request("GET_CHANNEL_PERMISSIONS")).data;
-    }
-    async getActivityInstanceConnectedParticipants() {
-        return (await this.client.request("GET_ACTIVITY_INSTANCE_CONNECTED_PARTICIPANTS")).data;
-    }
-    async navigateToConnections() {
-        return (await this.client.request("NAVIGATE_TO_CONNECTIONS")).data;
-    }
-    async createChanenlInvite(channelId, args) {
-        return (await this.client.request("CREATE_CHANNEL_INVITE", { channel_id: channelId, ...args })).data;
-    }
-    async openExternalLink(url) {
-        return (await this.client.request("OPEN_EXTERNAL_LINK", { url })).data;
-    }
-    async getPlatformBehaviors() {
-        return (await this.client.request("GET_PLATFORM_BEHAVIORS")).data;
-    }
-    async getProviderAccessToken(provider, connectionRedirect) {
-        return (await this.client.request("GET_PROVIDER_ACCESS_TOKEN", { provider, connectionRedirect })).data;
-    }
-    async maybeGetProviderAccessToken(provider) {
-        return (await this.client.request("MAYBE_GET_PROVIDER_ACCESS_TOKEN", { provider })).data;
-    }
-    async getSKUS() {
-        return (await this.client.request("GET_SKUS")).data;
-    }
-    async getEntitlements() {
-        return (await this.client.request("GET_ENTITLEMENTS")).data;
-    }
-    async getSKUsEmbedded() {
-        return (await this.client.request("GET_SKUS_EMBEDDED")).data;
-    }
-    async getEntitlementsEmbedded() {
-        return (await this.client.request("GET_ENTITLEMENTS_EMBEDDED")).data;
-    }
-    async encourageHardwareAcceleration() {
-        return (await this.client.request("ENCOURAGE_HW_ACCELERATION")).data;
-    }
-    async captureLog(level, message) {
-        return (await this.client.request("CAPTURE_LOG", { level, message })).data;
-    }
-    async sendAnalyticsEvent(eventName, eventProperties) {
-        return (await this.client.request("SEND_ANALYTICS_EVENT", { eventName, eventProperties })).data;
-    }
-    async getLocale() {
-        return (await this.client.request("USER_SETTINGS_GET_LOCALE")).data.locale;
-    }
-    async getAchievements() {
-        return (await this.client.request("GET_USER_ACHIEVEMENTS")).data;
-    }
-    async setAchievement(achievementId, percentComplete) {
-        return (await this.client.request("SET_USER_ACHIEVEMENT", {
-            achievement_id: achievementId,
-            percent_complete: percentComplete
-        })).data;
-    }
-    async createNetworkingToken() {
-        return (await this.client.request("NETWORKING_CREATE_TOKEN")).data;
-    }
-    async networkingPeerMetrics() {
-        return (await this.client.request("NETWORKING_PEER_METRICS")).data;
-    }
-    async networkingSystemMetrics() {
-        return (await this.client.request("NETWORKING_SYSTEM_METRICS")).data;
-    }
-    async getNetworkingConfig() {
-        return (await this.client.request("GET_NETWORKING_CONFIG")).data;
-    }
-    async startPurchase(skuId, pid) {
-        return (await this.client.request("START_PURCHASE", { sku_id: skuId, pid })).data;
-    }
-    async startPremiumPurchase(pid) {
-        return (await this.client.request("START_PREMIUM_PURCHASE", { pid })).data;
-    }
-    async getApplicationTicket() {
-        return (await this.client.request("GET_APPLICATION_TICKET")).data;
-    }
-    async getEntitlementTicket() {
-        return (await this.client.request("GET_ENTITLEMENT_TICKET")).data;
-    }
-    async validateApplication() {
-        return (await this.client.request("VALIDATE_APPLICATION")).data;
-    }
-    async openOverlayVoiceSettings(pid) {
-        return (await this.client.request("OPEN_OVERLAY_VOICE_SETTINGS", { pid })).data;
-    }
-    async openOverlayGuildInvite(code, pid) {
-        return (await this.client.request("OPEN_OVERLAY_GUILD_INVITE", { code, pid })).data;
-    }
-    async openOverlayActivityInvite(type, pid) {
-        const typeToNumber = {
-            JOIN: 0
-        };
-        return (await this.client.request("OPEN_OVERLAY_ACTIVITY_INVITE", { type: typeToNumber[type], pid })).data;
-    }
-    async setOverlayLocked(locked, pid) {
-        return (await this.client.request("SET_OVERLAY_LOCKED", { locked, pid })).data;
-    }
-    async browserHandoff() {
-        return (await this.client.request("BROWSER_HANDOFF")).data;
-    }
-    async openGuildTemplateBrowser(code) {
-        return (await this.client.request("GUILD_TEMPLATE_BROWSER", { code })).data;
-    }
-    async openGiftCodeBrowser(code) {
-        return (await this.client.request("GIFT_CODE_BROWSER", { code })).data;
-    }
-    async brainTreePopupBridgeCallback(state, path, query) {
-        return (await this.client.request("BRAINTREE_POPUP_BRIDGE_CALLBACK", { state, path, query })).data;
-    }
-    async billingPopupBridgeCallback(state, path, query, paymentSourceType) {
-        return (await this.client.request("BILLING_POPUP_BRIDGE_CALLBACK", {
-            state,
-            path,
-            query,
-            payment_source_type: paymentSourceType
-        })).data;
-    }
-    async connectionsCallback(providerType, code, openIdParams, state) {
-        return (await this.client.request("CONNECTIONS_CALLBACK", {
-            providerType: providerType,
-            code,
-            open_id_params: openIdParams,
-            state
-        })).data;
-    }
-    async deepLink(type, params) {
-        return (await this.client.request("DEEP_LINK", { type, params })).data;
-    }
-    async inviteBrowser(code) {
-        return (await this.client.request("INVITE_BROWSER", { code })).data;
-    }
-    async initiateImageUpload() {
-        return (await this.client.request("INITIATE_IMAGE_UPLOAD")).data;
-    }
-    async openShareMomentDialog(mediaUrl) {
-        return (await this.client.request("OPEN_SHARE_MOMENT_DIALOG", { mediaUrl })).data;
-    }
-    async openInviteDialog() {
-        return (await this.client.request("OPEN_INVITE_DIALOG")).data;
-    }
-    async acceptActivityInvite(type, userId, sessionId, channelId, messageId) {
-        const typeToNumber = {
-            JOIN: 0
-        };
-        return (await this.client.request("ACCEPT_ACTIVITY_INVITE", {
-            type: typeToNumber[type],
-            user_id: userId,
-            session_id: sessionId,
-            channel_id: channelId,
-            message_id: messageId
-        })).data;
-    }
-    async activityInviteUser(userId, type, content, pid) {
-        const typeToNumber = {
-            JOIN: 0
-        };
-        return (await this.client.request("ACTIVITY_INVITE_USER", {
-            user_id: userId,
-            type: typeToNumber[type],
-            content,
-            pid
-        })).data;
-    }
-    async closeActivityJoinRequest(userId) {
-        return (await this.client.request("CLOSE_ACTIVITY_JOIN_REQUEST", { user_id: userId })).data;
-    }
-    async sendActivityJoinInvite(userId, pid) {
-        return (await this.client.request("SEND_ACTIVITY_JOIN_INVITE", { user_id: userId, pid })).data;
-    }
-    async setConfig(useInteractivePip) {
-        return (await this.client.request("SET_CONFIG", { use_interactive_pip: useInteractivePip })).data;
-    }
+	// #region Helper function
+	async fetchUser(userId) {
+		return new User_1.User(
+			this.client,
+			(await this.client.request("GET_USER", { id: userId })).data,
+		);
+	}
+	/**
+	 * Used to get a guild the client is in.
+	 *
+	 * @param guildId - id of the guild to get
+	 * @param timeout - asynchronously get guild with time to wait before timing out
+	 * @returns partial guild
+	 */
+	async fetchGuild(guildId, timeout) {
+		return new Guild_1.Guild(
+			this.client,
+			(await this.client.request("GET_GUILD", { guild_id: guildId, timeout }))
+				.data,
+		);
+	}
+	/**
+	 * Used to get a list of guilds the client is in.
+	 * @returns the guilds the user is in
+	 */
+	async fetchGuilds() {
+		return (await this.client.request("GET_GUILDS")).data.guilds.map(
+			(guildData) => new Guild_1.Guild(this.client, guildData),
+		);
+	}
+	/**
+	 * Used to get a channel the client is in.
+	 * @param channelId - id of the channel to get
+	 * @returns partial channel
+	 */
+	async fetchChannel(channelId) {
+		return new Channel_1.Channel(
+			this.client,
+			(await this.client.request("GET_CHANNEL", { channel_id: channelId }))
+				.data,
+		);
+	}
+	/**
+	 * Used to get a guild's channels the client is in.
+	 * @param guildId - id of the guild to get channels for
+	 * @returns guild channels the user is in
+	 */
+	async fetchChannels(guildId) {
+		return (
+			await this.client.request("GET_CHANNELS", { guild_id: guildId })
+		).data.channels.map(
+			(channelData) => new Channel_1.Channel(this.client, channelData),
+		);
+	}
+	/**
+	 * Used to get the client's current voice channel. There are no arguments for this command. Returns the [Get Channel](https://discord.com/developers/docs/topics/rpc#getchannel) response, or `null` if none.
+	 * @returns the client's current voice channel, `null` if none
+	 */
+	async getSelectedVoiceChannel() {
+		const response = await this.client.request("GET_SELECTED_VOICE_CHANNEL");
+		return response.data !== null
+			? new Channel_1.Channel(this.client, response.data)
+			: null;
+	}
+	/**
+	 * Used to join voice channels, group dms, or dms. Returns the [Get Channel](https://discord.com/developers/docs/topics/rpc#getchannel) response, `null` if none.
+	 * @param channelId - channel id to join
+	 * @param timeout - asynchronously join channel with time to wait before timing out
+	 * @param force - forces a user to join a voice channel
+	 * @returns the channel that the user joined, `null` if none
+	 */
+	async selectVoiceChannel(channelId, timeout, force, navigate) {
+		return new Channel_1.Channel(
+			this.client,
+			(
+				await this.client.request("SELECT_VOICE_CHANNEL", {
+					channel_id: channelId,
+					timeout,
+					force,
+					navigate,
+				})
+			).data,
+		);
+	}
+	/**
+	 * Used to leave voice channels, group dms, or dms
+	 * @param timeout - asynchronously join channel with time to wait before timing out
+	 * @param force - forces a user to join a voice channel
+	 */
+	async leaveVoiceChannel(timeout, force) {
+		await this.client.request("SELECT_VOICE_CHANNEL", {
+			channel_id: null,
+			timeout,
+			force,
+		});
+	}
+	/**
+	 * Used to get current client's voice settings
+	 * @returns the voice setting
+	 */
+	async getVoiceSettings() {
+		return new VoiceSettings_1.VoiceSettings(
+			this.client,
+			(await this.client.request("GET_VOICE_SETTINGS")).data,
+		);
+	}
+	/**
+	 * Used by hardware manufacturers to send information about the current state of their certified devices that are connected to Discord.
+	 * @param devices - a list of devices for your manufacturer, in order of priority
+	 * @returns
+	 */
+	async setCeritfiedDevices(devices) {
+		await this.client.request("SET_CERTIFIED_DEVICES", { devices });
+	}
+	/**
+	 * Used to accept an Ask to Join request.
+	 * @param userId - the id of the requesting user
+	 */
+	async sendJoinInvite(userId) {
+		await this.client.request("SEND_ACTIVITY_JOIN_INVITE", { user_id: userId });
+	}
+	/**
+	 * Used to reject an Ask to Join request.
+	 * @param userId - the id of the requesting user
+	 */
+	async closeJoinRequest(userId) {
+		await this.client.request("CLOSE_ACTIVITY_JOIN_REQUEST", {
+			user_id: userId,
+		});
+	}
+	/**
+	 * Used to join text channels, group dms, or dms. Returns the [Get Channel](https://discord.com/developers/docs/topics/rpc#getchannel) response, or `null` if none.
+	 * @param channelId - channel id to join
+	 * @param timeout - asynchronously join channel with time to wait before timing out
+	 * @returns the text channel that user joined
+	 */
+	async selectTextChannel(channelId, timeout) {
+		return new Channel_1.Channel(
+			this.client,
+			(
+				await this.client.request("SELECT_TEXT_CHANNEL", {
+					channel_id: channelId,
+					timeout,
+				})
+			).data,
+		);
+	}
+	/**
+	 * Used to leave text channels, group dms, or dms.
+	 * @param timeout - asynchronously join channel with time to wait before timing out
+	 */
+	async leaveTextChannel(timeout) {
+		await this.client.request("SELECT_TEXT_CHANNEL", {
+			channel_id: null,
+			timeout,
+		});
+	}
+	async getRelationships() {
+		return (
+			await this.client.request("GET_RELATIONSHIPS")
+		).data.relationships.map((data) => {
+			return new User_1.User(this.client, {
+				...data.user,
+				presence: data.presence,
+			});
+		});
+	}
+	/**
+	 * Used to update a user's Rich Presence.
+	 *
+	 * @param activity - the rich presence to assign to the user
+	 * @param pid - the application's process id
+	 * @returns The activity that have been set
+	 */
+	async setActivity(activity, pid) {
+		const formattedAcitivity = {
+			...activity,
+			assets: {},
+			timestamps: {},
+			party: {},
+			secrets: {},
+		};
+		if (activity.startTimestamp instanceof Date) {
+			formattedAcitivity.timestamps.start = Math.round(
+				activity.startTimestamp.getTime(),
+			);
+		} else if (typeof activity.startTimestamp === "number") {
+			formattedAcitivity.timestamps.start = activity.startTimestamp;
+		}
+		if (activity.endTimestamp instanceof Date) {
+			formattedAcitivity.timestamps.end = Math.round(
+				activity.endTimestamp.getTime(),
+			);
+		} else if (typeof activity.endTimestamp === "number") {
+			formattedAcitivity.timestamps.end = activity.endTimestamp;
+		}
+		if (activity.largeImageKey)
+			formattedAcitivity.assets.large_image = activity.largeImageKey;
+		if (activity.smallImageKey)
+			formattedAcitivity.assets.small_image = activity.smallImageKey;
+		if (activity.largeImageText)
+			formattedAcitivity.assets.large_text = activity.largeImageText;
+		if (activity.smallImageText)
+			formattedAcitivity.assets.small_text = activity.smallImageText;
+		if (activity.partyId) formattedAcitivity.party.id = activity.partyId;
+		if (activity.partyPrivacy)
+			formattedAcitivity.party.privacy = activity.partyPrivacy;
+		if (activity.partySize && activity.partyMax)
+			formattedAcitivity.party.size = [activity.partySize, activity.partyMax];
+		if (activity.joinSecret)
+			formattedAcitivity.secrets.join = activity.joinSecret;
+		if (activity.spectateSecret)
+			formattedAcitivity.secrets.spectate = activity.spectateSecret;
+		if (activity.matchSecret)
+			formattedAcitivity.secrets.match = activity.matchSecret;
+		if (activity.supportedPlatforms)
+			formattedAcitivity.supported_platforms = activity.supportedPlatforms;
+		if (Object.keys(formattedAcitivity.assets).length === 0)
+			delete formattedAcitivity["assets"];
+		if (Object.keys(formattedAcitivity.timestamps).length === 0)
+			delete formattedAcitivity["timestamps"];
+		if (Object.keys(formattedAcitivity.party).length === 0)
+			delete formattedAcitivity["party"];
+		if (Object.keys(formattedAcitivity.secrets).length === 0)
+			delete formattedAcitivity["secrets"];
+		formattedAcitivity.instance = !!activity.instance;
+		// Clean-up
+		delete formattedAcitivity["startTimestamp"];
+		delete formattedAcitivity["endTimestamp"];
+		delete formattedAcitivity["largeImageKey"];
+		delete formattedAcitivity["smallImageKey"];
+		delete formattedAcitivity["largeImageText"];
+		delete formattedAcitivity["smallImageText"];
+		delete formattedAcitivity["partyId"];
+		delete formattedAcitivity["partyPrivacy"];
+		delete formattedAcitivity["partySize"];
+		delete formattedAcitivity["partyMax"];
+		delete formattedAcitivity["joinSecret"];
+		delete formattedAcitivity["spectateSecret"];
+		delete formattedAcitivity["matchSecret"];
+		delete formattedAcitivity["supportedPlatforms"];
+		return (
+			await this.client.request("SET_ACTIVITY", {
+				pid: (pid ?? process) ? (process.pid ?? 0) : 0,
+				activity: formattedAcitivity,
+			})
+		).data;
+	}
+	/**
+	 * Used to clear a user's Rich Presence.
+	 *
+	 * @param pid - the application's process id
+	 */
+	async clearActivity(pid) {
+		await this.client.request("SET_ACTIVITY", {
+			pid: (pid ?? process) ? (process.pid ?? 0) : 0,
+		});
+	}
+	// #region Undocumented
+	// This region holds method that are not documented by Discord BUT does exist
+	// Also most of this might not even be correct, use at your own risk
+	/**
+	 * Used to get a user's avatar
+	 * @param userId - id of the user to get the avatar of
+	 * @param format - image format
+	 * @param size - image size
+	 * @return base64 encoded image data
+	 */
+	async getImage(userId, format = "png", size = 1024) {
+		return (
+			await this.client.request("GET_IMAGE", {
+				type: "user",
+				id: userId,
+				format,
+				size,
+			})
+		).data.data_url;
+	}
+	/**
+	 * Requires RPC and RPC_VOICE_WRITE
+	 * @returns
+	 */
+	async getSoundboardSounds() {
+		return (await this.client.request("GET_SOUNDBOARD_SOUNDS")).data;
+	}
+	/**
+	 * Requires RPC and RPC_VOICE_WRITE
+	 * @returns
+	 */
+	async playSoundboardSound(guildId, soundId) {
+		return (
+			await this.client.request("PLAY_SOUNDBOARD_SOUND", {
+				guild_id: guildId,
+				sound_id: soundId,
+			})
+		).data;
+	}
+	/**
+	 * Requires RPC and RPC_VIDEO_WRITE
+	 * @returns
+	 */
+	async toggleVideo() {
+		return (await this.client.request("TOGGLE_VIDEO")).data;
+	}
+	/**
+	 * Requires RPC and RPC_SCREENSHARE_WRITE
+	 * @returns
+	 */
+	async toggleScreenshare(pid) {
+		return (await this.client.request("TOGGLE_SCREENSHARE", { pid })).data;
+	}
+	/**
+	 * Requires RPC and RPC_VOICE_WRITE
+	 * @returns
+	 */
+	async setPushToTalk(active) {
+		return (await this.client.request("PUSH_TO_TALK", { active })).data;
+	}
+	/**
+	 * Requires RPC and RPC_VOICE_WRITE
+	 * @returns
+	 */
+	async setVoiceSettings(req) {
+		return (await this.client.request("SET_USER_VOICE_SETTINGS", req)).data;
+	}
+	/**
+	 * Requires RPC and RPC_VOICE_WRITE
+	 * @returns
+	 */
+	async setVoiceSettings2(req) {
+		return (await this.client.request("SET_VOICE_SETTINGS_2", req)).data;
+	}
+	/**
+	 * Requires RPC and RPC_GUILDS_MEMBERS_READ
+	 * @returns
+	 */
+	async getChannelPermissions() {
+		return (await this.client.request("GET_CHANNEL_PERMISSIONS")).data;
+	}
+	async getActivityInstanceConnectedParticipants() {
+		return (
+			await this.client.request("GET_ACTIVITY_INSTANCE_CONNECTED_PARTICIPANTS")
+		).data;
+	}
+	async navigateToConnections() {
+		return (await this.client.request("NAVIGATE_TO_CONNECTIONS")).data;
+	}
+	async createChanenlInvite(channelId, args) {
+		return (
+			await this.client.request("CREATE_CHANNEL_INVITE", {
+				channel_id: channelId,
+				...args,
+			})
+		).data;
+	}
+	async openExternalLink(url) {
+		return (await this.client.request("OPEN_EXTERNAL_LINK", { url })).data;
+	}
+	async getPlatformBehaviors() {
+		return (await this.client.request("GET_PLATFORM_BEHAVIORS")).data;
+	}
+	async getProviderAccessToken(provider, connectionRedirect) {
+		return (
+			await this.client.request("GET_PROVIDER_ACCESS_TOKEN", {
+				provider,
+				connectionRedirect,
+			})
+		).data;
+	}
+	async maybeGetProviderAccessToken(provider) {
+		return (
+			await this.client.request("MAYBE_GET_PROVIDER_ACCESS_TOKEN", { provider })
+		).data;
+	}
+	async getSKUS() {
+		return (await this.client.request("GET_SKUS")).data;
+	}
+	async getEntitlements() {
+		return (await this.client.request("GET_ENTITLEMENTS")).data;
+	}
+	async getSKUsEmbedded() {
+		return (await this.client.request("GET_SKUS_EMBEDDED")).data;
+	}
+	async getEntitlementsEmbedded() {
+		return (await this.client.request("GET_ENTITLEMENTS_EMBEDDED")).data;
+	}
+	async encourageHardwareAcceleration() {
+		return (await this.client.request("ENCOURAGE_HW_ACCELERATION")).data;
+	}
+	async captureLog(level, message) {
+		return (await this.client.request("CAPTURE_LOG", { level, message })).data;
+	}
+	async sendAnalyticsEvent(eventName, eventProperties) {
+		return (
+			await this.client.request("SEND_ANALYTICS_EVENT", {
+				eventName,
+				eventProperties,
+			})
+		).data;
+	}
+	async getLocale() {
+		return (await this.client.request("USER_SETTINGS_GET_LOCALE")).data.locale;
+	}
+	async getAchievements() {
+		return (await this.client.request("GET_USER_ACHIEVEMENTS")).data;
+	}
+	async setAchievement(achievementId, percentComplete) {
+		return (
+			await this.client.request("SET_USER_ACHIEVEMENT", {
+				achievement_id: achievementId,
+				percent_complete: percentComplete,
+			})
+		).data;
+	}
+	async createNetworkingToken() {
+		return (await this.client.request("NETWORKING_CREATE_TOKEN")).data;
+	}
+	async networkingPeerMetrics() {
+		return (await this.client.request("NETWORKING_PEER_METRICS")).data;
+	}
+	async networkingSystemMetrics() {
+		return (await this.client.request("NETWORKING_SYSTEM_METRICS")).data;
+	}
+	async getNetworkingConfig() {
+		return (await this.client.request("GET_NETWORKING_CONFIG")).data;
+	}
+	async startPurchase(skuId, pid) {
+		return (await this.client.request("START_PURCHASE", { sku_id: skuId, pid }))
+			.data;
+	}
+	async startPremiumPurchase(pid) {
+		return (await this.client.request("START_PREMIUM_PURCHASE", { pid })).data;
+	}
+	async getApplicationTicket() {
+		return (await this.client.request("GET_APPLICATION_TICKET")).data;
+	}
+	async getEntitlementTicket() {
+		return (await this.client.request("GET_ENTITLEMENT_TICKET")).data;
+	}
+	async validateApplication() {
+		return (await this.client.request("VALIDATE_APPLICATION")).data;
+	}
+	async openOverlayVoiceSettings(pid) {
+		return (await this.client.request("OPEN_OVERLAY_VOICE_SETTINGS", { pid }))
+			.data;
+	}
+	async openOverlayGuildInvite(code, pid) {
+		return (
+			await this.client.request("OPEN_OVERLAY_GUILD_INVITE", { code, pid })
+		).data;
+	}
+	async openOverlayActivityInvite(type, pid) {
+		const typeToNumber = {
+			JOIN: 0,
+		};
+		return (
+			await this.client.request("OPEN_OVERLAY_ACTIVITY_INVITE", {
+				type: typeToNumber[type],
+				pid,
+			})
+		).data;
+	}
+	async setOverlayLocked(locked, pid) {
+		return (await this.client.request("SET_OVERLAY_LOCKED", { locked, pid }))
+			.data;
+	}
+	async browserHandoff() {
+		return (await this.client.request("BROWSER_HANDOFF")).data;
+	}
+	async openGuildTemplateBrowser(code) {
+		return (await this.client.request("GUILD_TEMPLATE_BROWSER", { code })).data;
+	}
+	async openGiftCodeBrowser(code) {
+		return (await this.client.request("GIFT_CODE_BROWSER", { code })).data;
+	}
+	async brainTreePopupBridgeCallback(state, path, query) {
+		return (
+			await this.client.request("BRAINTREE_POPUP_BRIDGE_CALLBACK", {
+				state,
+				path,
+				query,
+			})
+		).data;
+	}
+	async billingPopupBridgeCallback(state, path, query, paymentSourceType) {
+		return (
+			await this.client.request("BILLING_POPUP_BRIDGE_CALLBACK", {
+				state,
+				path,
+				query,
+				payment_source_type: paymentSourceType,
+			})
+		).data;
+	}
+	async connectionsCallback(providerType, code, openIdParams, state) {
+		return (
+			await this.client.request("CONNECTIONS_CALLBACK", {
+				providerType: providerType,
+				code,
+				open_id_params: openIdParams,
+				state,
+			})
+		).data;
+	}
+	async deepLink(type, params) {
+		return (await this.client.request("DEEP_LINK", { type, params })).data;
+	}
+	async inviteBrowser(code) {
+		return (await this.client.request("INVITE_BROWSER", { code })).data;
+	}
+	async initiateImageUpload() {
+		return (await this.client.request("INITIATE_IMAGE_UPLOAD")).data;
+	}
+	async openShareMomentDialog(mediaUrl) {
+		return (await this.client.request("OPEN_SHARE_MOMENT_DIALOG", { mediaUrl }))
+			.data;
+	}
+	async openInviteDialog() {
+		return (await this.client.request("OPEN_INVITE_DIALOG")).data;
+	}
+	async acceptActivityInvite(type, userId, sessionId, channelId, messageId) {
+		const typeToNumber = {
+			JOIN: 0,
+		};
+		return (
+			await this.client.request("ACCEPT_ACTIVITY_INVITE", {
+				type: typeToNumber[type],
+				user_id: userId,
+				session_id: sessionId,
+				channel_id: channelId,
+				message_id: messageId,
+			})
+		).data;
+	}
+	async activityInviteUser(userId, type, content, pid) {
+		const typeToNumber = {
+			JOIN: 0,
+		};
+		return (
+			await this.client.request("ACTIVITY_INVITE_USER", {
+				user_id: userId,
+				type: typeToNumber[type],
+				content,
+				pid,
+			})
+		).data;
+	}
+	async closeActivityJoinRequest(userId) {
+		return (
+			await this.client.request("CLOSE_ACTIVITY_JOIN_REQUEST", {
+				user_id: userId,
+			})
+		).data;
+	}
+	async sendActivityJoinInvite(userId, pid) {
+		return (
+			await this.client.request("SEND_ACTIVITY_JOIN_INVITE", {
+				user_id: userId,
+				pid,
+			})
+		).data;
+	}
+	async setConfig(useInteractivePip) {
+		return (
+			await this.client.request("SET_CONFIG", {
+				use_interactive_pip: useInteractivePip,
+			})
+		).data;
+	}
 }
 exports.ClientUser = ClientUser;
